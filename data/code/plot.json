{"altair_plot_code": "import altair as alt\nimport gradio as gr\nimport numpy as np\nimport pandas as pd\nfrom vega_datasets import data\n\n\ndef make_plot(plot_type):\n    if plot_type == \"scatter_plot\":\n        cars = data.cars()\n        return alt.Chart(cars).mark_point().encode(\n            x='Horsepower',\n            y='Miles_per_Gallon',\n            color='Origin',\n        )\n    elif plot_type == \"heatmap\":\n        # Compute x^2 + y^2 across a 2D grid\n        x, y = np.meshgrid(range(-5, 5), range(-5, 5))\n        z = x ** 2 + y ** 2\n\n        # Convert this grid to columnar data expected by Altair\n        source = pd.DataFrame({'x': x.ravel(),\n                               'y': y.ravel(),\n                               'z': z.ravel()})\n        return alt.Chart(source).mark_rect().encode(\n            x='x:O',\n            y='y:O',\n            color='z:Q'\n        )\n    elif plot_type == \"us_map\":\n        states = alt.topo_feature(data.us_10m.url, 'states')\n        source = data.income.url\n\n        return alt.Chart(source).mark_geoshape().encode(\n            shape='geo:G',\n            color='pct:Q',\n            tooltip=['name:N', 'pct:Q'],\n            facet=alt.Facet('group:N', columns=2),\n        ).transform_lookup(\n            lookup='id',\n            from_=alt.LookupData(data=states, key='id'),\n            as_='geo'\n        ).properties(\n            width=300,\n            height=175,\n        ).project(\n            type='albersUsa'\n        )\n    elif plot_type == \"interactive_barplot\":\n        source = data.movies.url\n\n        pts = alt.selection(type=\"single\", encodings=['x'])\n\n        rect = alt.Chart(data.movies.url).mark_rect().encode(\n            alt.X('IMDB_Rating:Q', bin=True),\n            alt.Y('Rotten_Tomatoes_Rating:Q', bin=True),\n            alt.Color('count()',\n                      scale=alt.Scale(scheme='greenblue'),\n                      legend=alt.Legend(title='Total Records')\n                      )\n        )\n\n        circ = rect.mark_point().encode(\n            alt.ColorValue('grey'),\n            alt.Size('count()',\n                     legend=alt.Legend(title='Records in Selection')\n                     )\n        ).transform_filter(\n            pts\n        )\n\n        bar = alt.Chart(source).mark_bar().encode(\n            x='Major_Genre:N',\n            y='count()',\n            color=alt.condition(pts, alt.ColorValue(\n                \"steelblue\"), alt.ColorValue(\"grey\"))\n        ).properties(\n            width=550,\n            height=200\n        ).add_selection(pts)\n\n        plot = alt.vconcat(\n            rect + circ,\n            bar\n        ).resolve_legend(\n            color=\"independent\",\n            size=\"independent\"\n        )\n        return plot\n    elif plot_type == \"radial\":\n        source = pd.DataFrame({\"values\": [12, 23, 47, 6, 52, 19]})\n\n        base = alt.Chart(source).encode(\n            theta=alt.Theta(\"values:Q\", stack=True),\n            radius=alt.Radius(\"values\", scale=alt.Scale(\n                type=\"sqrt\", zero=True, rangeMin=20)),\n            color=\"values:N\",\n        )\n\n        c1 = base.mark_arc(innerRadius=20, stroke=\"#fff\")\n\n        c2 = base.mark_text(radiusOffset=10).encode(text=\"values:Q\")\n\n        return c1 + c2\n    elif plot_type == \"multiline\":\n        source = data.stocks()\n\n        highlight = alt.selection(type='single', on='mouseover',\n                                  fields=['symbol'], nearest=True)\n\n        base = alt.Chart(source).encode(\n            x='date:T',\n            y='price:Q',\n            color='symbol:N'\n        )\n\n        points = base.mark_circle().encode(\n            opacity=alt.value(0)\n        ).add_selection(\n            highlight\n        ).properties(\n            width=600\n        )\n\n        lines = base.mark_line().encode(\n            size=alt.condition(~highlight, alt.value(1), alt.value(3))\n        )\n\n        return points + lines\n\n\nwith gr.Blocks() as demo:\n    button = gr.Radio(label=\"Plot type\",\n                      choices=['scatter_plot', 'heatmap', 'us_map',\n                               'interactive_barplot', \"radial\", \"multiline\"], value='scatter_plot')\n    plot = gr.Plot(label=\"Plot\")\n    button.change(make_plot, inputs=button, outputs=[plot])\n    demo.load(make_plot, inputs=[button], outputs=[plot])\n\n\nif __name__ == \"__main__\":\n    demo.launch()\n", "outbreak_forecast_code": "import altair\n\nimport gradio as gr\nfrom math import sqrt\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport plotly.express as px\nimport pandas as pd\n\n\ndef outbreak(plot_type, r, month, countries, social_distancing):\n    months = [\"January\", \"February\", \"March\", \"April\", \"May\"]\n    m = months.index(month)\n    start_day = 30 * m\n    final_day = 30 * (m + 1)\n    x = np.arange(start_day, final_day + 1)\n    pop_count = {\"USA\": 350, \"Canada\": 40, \"Mexico\": 300, \"UK\": 120}\n    if social_distancing:\n        r = sqrt(r)\n    df = pd.DataFrame({\"day\": x})\n    for country in countries:\n        df[country] = x ** (r) * (pop_count[country] + 1)\n\n    if plot_type == \"Matplotlib\":\n        fig = plt.figure()\n        plt.plot(df[\"day\"], df[countries].to_numpy())\n        plt.title(\"Outbreak in \" + month)\n        plt.ylabel(\"Cases\")\n        plt.xlabel(\"Days since Day 0\")\n        plt.legend(countries)\n        return fig\n    elif plot_type == \"Plotly\":\n        fig = px.line(df, x=\"day\", y=countries)\n        fig.update_layout(\n            title=\"Outbreak in \" + month,\n            xaxis_title=\"Cases\",\n            yaxis_title=\"Days Since Day 0\",\n        )\n        return fig\n    elif plot_type == \"Altair\":\n        df = df.melt(id_vars=\"day\").rename(columns={\"variable\": \"country\"})\n        fig = altair.Chart(df).mark_line().encode(\n            x=\"day\", y='value', color='country')\n        return fig\n    else:\n        raise ValueError(\"A plot type must be selected\")\n\n\ninputs = [\n    gr.Dropdown([\"Matplotlib\", \"Plotly\", \"Altair\"], label=\"Plot Type\"),\n    gr.Slider(1, 4, 3.2, label=\"R\"),\n    gr.Dropdown([\"January\", \"February\", \"March\",\n                \"April\", \"May\"], label=\"Month\"),\n    gr.CheckboxGroup(\n        [\"USA\", \"Canada\", \"Mexico\", \"UK\"], label=\"Countries\", value=[\"USA\", \"Canada\"]\n    ),\n    gr.Checkbox(label=\"Social Distancing?\"),\n]\noutputs = gr.Plot()\n\ndemo = gr.Interface(\n    fn=outbreak,\n    inputs=inputs,\n    outputs=outputs,\n    examples=[\n        [\"Matplotlib\", 2, \"March\", [\"Mexico\", \"UK\"], True],\n        [\"Altair\", 2, \"March\", [\"Mexico\", \"Canada\"], True],\n        [\"Plotly\", 3.6, \"February\", [\"Canada\", \"Mexico\", \"UK\"], False],\n    ],\n    cache_examples=True,\n)\n\nif __name__ == \"__main__\":\n    demo.launch()\n", "blocks_kinematics_code": "import pandas as pd\nimport numpy as np\n\nimport gradio as gr\n\n\ndef plot(v, a):\n    g = 9.81\n    theta = a / 180 * 3.14\n    tmax = ((2 * v) * np.sin(theta)) / g\n    timemat = tmax * np.linspace(0, 1, 40)\n\n    x = (v * timemat) * np.cos(theta)\n    y = ((v * timemat) * np.sin(theta)) - ((0.5 * g) * (timemat**2))\n    df = pd.DataFrame({\"x\": x, \"y\": y})\n    return df\n\n\ndemo = gr.Blocks()\n\nwith demo:\n    gr.Markdown(\n        r\"Let's do some kinematics! Choose the speed and angle to see the trajectory. Remember that the range $R = v_0^2 \\cdot \\frac{\\sin(2\\theta)}{g}$\"\n    )\n\n    with gr.Row():\n        speed = gr.Slider(1, 30, 25, label=\"Speed\")\n        angle = gr.Slider(0, 90, 45, label=\"Angle\")\n    output = gr.LinePlot(\n        x=\"x\",\n        y=\"y\",\n        overlay_point=True,\n        tooltip=[\"x\", \"y\"],\n        x_lim=[0, 100],\n        y_lim=[0, 60],\n        width=350,\n        height=300,\n    )\n    btn = gr.Button(value=\"Run\")\n    btn.click(plot, [speed, angle], output)\n\nif __name__ == \"__main__\":\n    demo.launch()\n", "stock_forecast_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport gradio as gr\n\n\ndef plot_forecast(final_year, companies, noise, show_legend, point_style):\n    start_year = 2020\n    x = np.arange(start_year, final_year + 1)\n    year_count = x.shape[0]\n    plt_format = ({\"cross\": \"X\", \"line\": \"-\", \"circle\": \"o--\"})[point_style]\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    for i, company in enumerate(companies):\n        series = np.arange(0, year_count, dtype=float)\n        series = series**2 * (i + 1)\n        series += np.random.rand(year_count) * noise\n        ax.plot(x, series, plt_format)\n    if show_legend:\n        plt.legend(companies)\n    return fig\n\n\ndemo = gr.Interface(\n    plot_forecast,\n    [\n        gr.Radio([2025, 2030, 2035, 2040], label=\"Project to:\"),\n        gr.CheckboxGroup([\"Google\", \"Microsoft\", \"Gradio\"],\n                         label=\"Company Selection\"),\n        gr.Slider(1, 100, label=\"Noise Level\"),\n        gr.Checkbox(label=\"Show Legend\"),\n        gr.Dropdown([\"cross\", \"line\", \"circle\"], label=\"Style\"),\n    ],\n    gr.Plot(label=\"forecast\"),\n)\n\nif __name__ == \"__main__\":\n    demo.launch()\n", "map_airbnb_code": "import gradio as gr\nimport plotly.graph_objects as go\nfrom datasets import load_dataset\n\ndataset = load_dataset(\"gradio/NYC-Airbnb-Open-Data\", split=\"train\")\ndf = dataset.to_pandas()\n\n\ndef filter_map(min_price, max_price, boroughs):\n\n    filtered_df = df[(df['neighbourhood_group'].isin(boroughs)) &\n                     (df['price'] > min_price) & (df['price'] < max_price)]\n    names = filtered_df[\"name\"].tolist()\n    prices = filtered_df[\"price\"].tolist()\n    text_list = [(names[i], prices[i]) for i in range(0, len(names))]\n    fig = go.Figure(go.Scattermapbox(\n        customdata=text_list,\n        lat=filtered_df['latitude'].tolist(),\n        lon=filtered_df['longitude'].tolist(),\n        mode='markers',\n        marker=go.scattermapbox.Marker(\n            size=6\n        ),\n        hoverinfo=\"text\",\n        hovertemplate='<b>Name</b>: %{customdata[0]}<br><b>Price</b>: $%{customdata[1]}'\n    ))\n\n    fig.update_layout(\n        mapbox_style=\"open-street-map\",\n        hovermode='closest',\n        mapbox=dict(\n            bearing=0,\n            center=go.layout.mapbox.Center(\n                lat=40.67,\n                lon=-73.90\n            ),\n            pitch=0,\n            zoom=9\n        ),\n    )\n\n    return fig\n\n\nwith gr.Blocks() as demo:\n    with gr.Column():\n        with gr.Row():\n            min_price = gr.Number(value=250, label=\"Minimum Price\")\n            max_price = gr.Number(value=1000, label=\"Maximum Price\")\n        boroughs = gr.CheckboxGroup(choices=[\"Queens\", \"Brooklyn\", \"Manhattan\", \"Bronx\", \"Staten Island\"], value=[\n                                    \"Queens\", \"Brooklyn\"], label=\"Select Boroughs:\")\n        btn = gr.Button(value=\"Update Filter\")\n        map = gr.Plot()\n    demo.load(filter_map, [min_price, max_price, boroughs], map)\n    btn.click(filter_map, [min_price, max_price, boroughs], map)\n\nif __name__ == \"__main__\":\n    demo.launch()\n"}